= Redpanda Schema Registry
:description: Redpanda's Schema Registry provides the interface to store and manage event schemas.
:page-aliases: console:features/schema-registry.adoc, manage:console/schema-registry.adoc
:page-categories: Management, Schema Registry


In Redpanda, the messages exchanged between producers and consumers contain raw bytes. Schemas enable producers and consumers to share the information needed to serialize and deserialize those messages. They register and retrieve the schemas they use in the Schema Registry to ensure data verification. 

Schemas are versioned, and the registry supports configurable compatibility modes between schema versions. When a producer or a consumer makes a request to register a schema change, the registry checks for schema compatibility and returns an error for an incompatible change. Compatibility modes can ensure that data flowing through a system is well-structured and easily evolves over time. 

[NOTE]
====
The Schema Registry is built directly into the Redpanda binary. It runs out-of-the-box with Redpanda's default configuration, and it requires no new binaries to install and no new services to deploy or maintain. You can use it with the xref:manage:schema-reg/schema-reg-api.adoc[Schema Registry API] or xref:manage:schema-reg/schema-reg-ui.adoc[Redpanda Console]. 
====

== Schema terminology

**Schema**: A schema is an external mechanism to describe the structure of data and its encoding. Producer clients and consumer clients use a schema as an agreed-upon format for sending and receiving messages. Schemas enable a loosely coupled, data-centric architecture that minimizes dependencies in code, between teams, and between producers and consumers.

**Subject**: A subject is a logical grouping for schemas. When data formats are updated, a new version of the schema can be registered under the same subject, allowing for backward and forward compatibility. A subject may have more than one schema version assigned to it, with each schema having a different numeric ID.

**Serialization format**: A serialization format defines how data is converted into bytes that are transmitted and stored. Serialization, by producers, converts an event into bytes. Redpanda then stores these bytes in topics. Deserialization, by consumers, converts the bytes of arrays back into the desired data format. Redpanda's Schema Registry supports Avro and Protobuf serialization formats.

== Redpanda design overview

Every broker allows mutating REST calls, so there's no need to configure leadership or failover strategies. Schemas are stored in a compacted topic, and the registry uses optimistic concurrency control at the topic level to detect and avoid collisions.

The Schema Registry publishes record metadata to an internal topic, `_schemas`, as its backend store. By default, `_schemas` is protected from deletion and configuration changes by Kafka clients (see the xref:reference:cluster-properties.adoc#kafka_nodelete_topics[kafka_nodelete_topics] cluster property).

Redpanda Schema Registry uses the default port 8081. 

== Schema examples

To experiment with schemas from applications, see the clients in https://github.com/redpanda-data/redpanda-labs/tree/main[redpanda-labs^].

For a basic end-to-end example, the following Protobuf schema contains information about products: a unique ID, name, price, and category. It has a schema ID of 1, and the Topic name strategy, with a topic of Orders. (The Topic strategy is suitable when you want to group schemas by the topics to which they are associated.) 

[,json]
----
syntax = "proto3";

message Product {
  int32 ProductID = 1;
  string ProductName = 2;
  double Price = 3;
  string Category = 4;
}
----

The producer then does something like this: 

[,json]
----
from kafka import KafkaProducer
from productpy import Product  # This imports the prototyped schema

# Create a Kafka producer
producer = KafkaProducer(bootstrap_servers='your_kafka_brokers')

# Create a Product message
product_message = Product(
    ProductID=123,
    ProductName="Example Product",
    Price=45.99,
    Category="Electronics"
)

# Produce the Product message to the "Orders" topic
producer.send('Orders', key='product_key', value=product_message.SerializeToString())
----

To add an additional field for product variants, like size or color, the new schema (version 2, ID 2) would look like this: 

[,json]
----
syntax = "proto3";

message Product {
  int32 ProductID = 1;
  string ProductName = 2;
  double Price = 3;
  string Category = 4;
  repeated string Variants = 5;
}
----

You would want the compatibility setting to accommodate adding new fields without breakage. Adding an optional new field to a schema is inherently backward-compatible. New consumers can process events written with the new schema, and older consumers can ignore it. 

== Next steps
* xref:manage:schema-reg/schema-reg-api.adoc[]
* xref:manage:schema-reg/schema-reg-ui.adoc[]

== Suggested reading

* xref:reference:console/record-deserialization.adoc[]
* xref:api:ROOT:pandaproxy-schema-registry.adoc[Schema Registry API]
* xref:reference:node-configuration-sample.adoc[] (search for `schema_registry`)
* xref:manage:monitoring.adoc#service-level-queries[Monitor Schema Registry service-level metrics]
* xref:deploy:deployment-option/self-hosted/manual/node-property-configuration.adoc[Configure broker properties for Schema Registry]
