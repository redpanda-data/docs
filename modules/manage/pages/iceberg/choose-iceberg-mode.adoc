= Choose an Iceberg Mode
:description: Learn about supported Iceberg modes and how you can integrate schemas with Iceberg topics.
:page-categories: Iceberg, Tiered Storage, Management, High Availability, Data Replication, Integration
:schema-id-val-doc: manage:schema-reg/schema-id-validation.adoc
// tag::single-source[]

ifndef::env-cloud[]
[NOTE]
====
include::shared:partial$enterprise-license.adoc[]
====
endif::[]

In xref:manage:iceberg/about-iceberg-topics.adoc[Iceberg-enabled clusters], the `redpanda.iceberg.mode` topic property determines how Redpanda maps topic data to the Iceberg table structure. You can have the generated Iceberg table match the structure of an Avro or Protobuf schema in the Schema Registry, or you can use the `key_value` mode where Redpanda stores the record values as-is in the table. 

NOTE: The JSON Schema format is not supported for Iceberg topics. If your topic data is in JSON, use the `key_value` mode. 

== Supported Iceberg modes

Redpanda supports the following modes for Iceberg topics:

=== key_value

Creates an Iceberg table using a simple schema, consisting of two columns, one for the record metadata including the key, and another binary column for the record's value.

=== value_schema_id_prefix

Creates an Iceberg table whose structure matches the Redpanda schema for the topic, with columns corresponding to each field. You must register a schema in the xref:manage:schema-reg/schema-reg-overview.adoc[Schema Registry] and producers must write to the topic using the Schema Registry wire format.

ifndef::env-cloud[]
In the Schema Registry wire format, a "magic byte" and schema ID are embedded in the message payload header. Producers to the topic must use the wire format in the serialization process so Redpanda can determine the schema used for each record, use the schema to define the Iceberg table, and store the topic values in the corresponding table columns. See also: xref:{schema-id-val-doc}[] and 
the https://www.redpanda.com/blog/schema-registry-kafka-streaming#how-does-serialization-work-with-schema-registry-in-kafka[Understanding Apache Kafka Schema Registry^] blog post.

ifdef::env-cloud[]
In the Schema Registry wire format, a "magic byte" and schema ID are embedded in the message payload header. Producers to the topic must use the wire format in the serialization process so Redpanda can determine the schema used for each record, use the schema to define the Iceberg table, and store the topic values in the corresponding table columns. See also: the https://www.redpanda.com/blog/schema-registry-kafka-streaming#how-does-serialization-work-with-schema-registry-in-kafka[Understanding Apache Kafka Schema Registry^] blog post.
endif::[]

=== value_schema_latest

Creates an Iceberg table whose structure matches the latest schema registered for the subject in the Schema Registry. You must register a schema in the xref:manage:schema-reg/schema-reg-overview.adoc[Schema Registry]. Unlike the `value_schema_id_prefix` mode,  `value_schema_latest` does not require that producers use the wire format.

=== disabled

Default for `redpanda.iceberg.mode`. Disables writing to an Iceberg table for the topic.

== Configure Iceberg mode for topic

You can set the Iceberg mode for a topic when you create the topic, or you can update the mode for an existing topic.

.Create a new topic and set `redpanda.iceberg.mode`:
[,bash]
----
rpk topic create <topic-name> --topic-config=redpanda.iceberg.mode=<iceberg-mode>
----

.Set `redpanda.iceberg.mode` for an existing topic:
[,bash]
----
rpk topic alter-config <new-topic-name> --set redpanda.iceberg.mode=<iceberg-mode>
----

[[override-value-schema-latest-default]]
=== Override `value_schema_latest` default

In `value_schema_latest` mode, only the string `value_schema_latest` is required in the property value. This sets `value_schema_latest` mode to its default behavior, which derives the subject for the topic using xref:manage:schema-reg/schema-id-validation.adoc#set-subject-name-strategy-per-topic[TopicNameStrategy]. For Protobuf data, the default behavior also deserializes records using the first message within the corresponding Protobuf schema in the Schema Registry.

To override the default behavior, use the following optional syntax:

[,bash]
----
value_schema_latest:subject=<subject-name>,protobuf_name=<protobuf-message-full-name>
----

* For both Avro and Protobuf, specify a different subject name by using the key-value pair `subject=<subject-name>`, for example `value_schema_latest:subject=sensor-data`.
* For Protobuf only:
** Specify a different message definition by using a key-value pair `protobuf_name=<message-name>`, for example `value_schema_latest:protobuf_name=com.example.manufacturing.SensorData`.
** To specify both a different subject and message definition, separate the key-value pairs with a comma, for example `value_schema_latest:subject=my_protobuf_schema,protobuf_name=com.example.manufacturing.SensorData`.

== How Iceberg modes translate to table format

Redpanda generates an Iceberg table with the same name as the topic. In each mode, Redpanda writes to a `redpanda` table column that stores a single Iceberg https://iceberg.apache.org/spec/#nested-types[struct^] per record, containing nested columns of the metadata from each record, including the record key, headers, timestamp, the partition it belongs to, and its offset. 

For example, if you produce to a topic `ClickEvent` according to the following Avro schema:

[,avro]
----
{
    "type": "record",
    "name": "ClickEvent",
    "fields": [
        {
            "name": "user_id",
            "type": "int"
        },
        {
            "name": "event_type",
            "type": "string"
        },
        {
            "name": "ts",
            "type": "string"
        }
    ]
}
----

The `key_value` mode writes to the following table format:

[,sql]
----
CREATE TABLE ClickEvent (
    redpanda struct<
        partition: integer NOT NULL,
        timestamp: timestamp NOT NULL,
        offset:    long NOT NULL,
        headers:   array<struct<key: binary NOT NULL, value: binary>>,
        key:       binary
    >,
    value binary
)
----

Use `key_value` mode if the topic data is in JSON or if you can use the Iceberg data in its semi-structured format.

The `value_schema_id_prefix` and `value_schema_latest` modes can use the schema to translate to the following table format:

[,sql]
----
CREATE TABLE ClickEvent (
    redpanda struct<
        partition: integer NOT NULL,
        timestamp: timestamp NOT NULL,
        offset:    long NOT NULL,
        headers:   array<struct<key: binary NOT NULL, value: binary>>,
        key:       binary
    >,
    user_id integer NOT NULL,
    event_type string,
    ts string
)
----

As you produce records to the topic, the data also becomes available in object storage for Iceberg-compatible clients to consume. You can use the same analytical tools to xref:manage:iceberg/query-iceberg-topics.adoc[read the Iceberg topic data] in a data lake as you would for a relational database.

If Redpanda fails to translate the record to the columnar format as defined by the schema, it writes the record to a dead-letter queue (DLQ) table. See xref:manage:iceberg/about-iceberg-topics.adoc#manage-dead-letter-queue[Manage dead-letter queue] for more information.

// end::single-source[]

== See also

- xref:reference:properties/topic-properties.adoc#redpanda-iceberg-mode[`redpanda.iceberg.mode` topic property reference]
