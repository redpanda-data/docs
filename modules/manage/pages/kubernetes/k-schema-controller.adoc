= Manage Schemas with the Redpanda Operator
:description: Use the Schema resource to declaratively create and manage schemas as part of a Redpanda deployment in Kubernetes.
:page-categories: Management, Development
:env-kubernetes: true

Use the Schema resource to declaratively create and manage schemas as part of a Redpanda deployment in Kubernetes. Each Schema resource maps to a schema in your Redpanda cluster, allowing you to define data structures, compatibility, and schema evolution in a declarative way.

== Prerequisites

Ensure you have the following:

* *Kubectl*: Ensure you have the https://kubernetes.io/docs/tasks/tools/#kubectl[kubectl^] command-line tool installed and configured to communicate with your cluster.
* *Redpanda cluster*: Ensure you have at least version v2.2.2-24.2.4 of the xref:deploy:deployment-option/self-hosted/kubernetes/k-production-deployment.adoc[Redpanda Operator] and a Redpanda resource deployed and accessible.

== Create a schema

. Define a schema with the Schema resource:
+
.`schema.yaml`
[source,yaml]
----
apiVersion: cluster.redpanda.com/v1alpha2
kind: Schema
metadata:
  name: <subject-name> <.>
  namespace: <namespace> <.>
spec:
  cluster:
    clusterRef:
      name: <cluster-name> <.>
  schemaType: avro <.>
  compatibilityLevel: Backward <.>
  references: [] <.>
  text: | <.>
    {
      "type": "record",
      "name": "test",
      "fields": [
        { "type": "string", "name": "field1" },
        { "type": "int", "name": "field2" }
      ]
    }
----
+
<.> *Subject name*: The name of the subject for the schema. When data formats are updated, a new version of the schema can be registered under the same subject, enabling backward and forward compatibility.
<.> *Namespace*: The namespace in which to deploy the Schema resource. The Schema resource must be deployed in the same namespace as the Redpanda resource defined in `clusterRef.name`.
<.> *Cluster name*: The name of the Redpanda resource that defines the Redpanda cluster to which you want to upload the schema.
<.> *Compatibility level*: Defines the compatibility level for the schema. Options are `Backward` (default), `BackwardTransitive`, `Forward`, `ForwardTransitive` `Full`, `FullTransitive`, or `None`. See <<Choose a compatibility mode>>.
<.> *Schema type*: Specifies the type of the schema. Options are `avro` (default) or `protobuf`. For JSON Schema, include `"$schema":` in the `text` to indicate the JSON Schema draft version. See <<Choose a schema type>>.
<.> *References*: Any references you want to add to other schemas. If no references are needed, this can be an empty list (default). See <<Use schema references>>.
<.> *Schema body*: The body of the schema, which defines the data structure.

. Apply the schema:

[source,bash]
----
kubectl apply -f schema.yaml --namespace <namespace>
----

== Verify schema creation

Check that the schema was created in Redpanda:

[source,bash]
----
kubectl exec -it --namespace <namespace> <pod-name> -- curl https://<pod-name>.<cluster-name>.<namespace>.svc.cluster.local:8081/subjects -sS --cacert /etc/tls/certs/default/ca.crt -w '\n'
----

Replace `<pod-name>` with the name of a Pod that's running Redpanda.

== Configuration

The Schema resource in Redpanda offers various options to customize and control schema behavior. This section covers schema compatibility, schema references, schema types, providing a detailed guide on using each of these features to maintain data integrity, manage dependencies, and facilitate schema evolution.

You can find all configuration options for the Schema resource in the xref:reference:k-crd.adoc#k8s-api-github-com-redpanda-data-redpanda-operator-operator-api-redpanda-v1alpha2-schema[CRD reference].

=== Choose a compatibility mode

Compatibility modes determine how schema versions within a subject can evolve without breaking existing data consumers. Redpanda supports the following compatibility levels:

* `None`: Disables compatibility checks, allowing any schema change.
* `Backward`: New schemas are backward-compatible with previous versions, ensuring that new consumers can read data created with older schemas.
* `BackwardTransitive`: Enforces backward compatibility across all versions, not just the latest.
* `Forward`: New consumers can process data written with older schemas, allowing forward compatibility.
* `ForwardTransitive`: Ensures forward compatibility across all schema versions.
* `Full`: Combines backward and forward compatibility, requiring that changes maintain compatibility in both directions.
* `FullTransitive`: Enforces full compatibility across all schema versions.

For example, to set backward compatibility, configure the Schema resource with:

[source,yaml]
----
apiVersion: cluster.redpanda.com/v1alpha2
kind: Schema
metadata:
  name: mytopic-value
  namespace: redpanda
spec:
  cluster:
    clusterRef:
      name: basic
  compatibility: Backward
  text: |
    {
      "type": "record",
      "name": "example",
      "fields": [
        { "type": "string", "name": "field1" }
      ]
    }
----

Compatibility settings are essential for maintaining data consistency, especially when updating schemas over time.

=== Use schema references

For complex data structures, you can define schema references that allow one schema to reference another, enabling modular and reusable schema components. Schema references are helpful for shared data structures like product information or user profiles across topics, reducing redundancy.

NOTE: This feature is supported for Avro and Protobuf schemas.

Define a schema reference using the `references` field. The reference includes the name, subject, and version of the referenced schema:

[source,yaml]
----
apiVersion: cluster.redpanda.com/v1alpha2
kind: Schema
metadata:
  name: order-schema
  namespace: redpanda
spec:
  cluster:
    clusterRef:
      name: basic
  references:
    - name: product-schema
      subject: product
      version: 1
  text: |
    {
      "type": "record",
      "name": "Order",
      "fields": [
        { "name": "product", "type": "Product" }
      ]
    }
----

=== Choose a schema type

Redpanda's Schema Registry supports the following schema types:

* *Avro*: A widely used serialization format in event-driven architectures.
* *Protobuf*: Popular for defining data structures in gRPC APIs and efficient data serialization.
* *JSON Schema*: Dynamic, schema-based validation for JSON documents.

If no type is specified, Redpanda defaults to Avro.

For example, an Protobuf schema definition might look like this:

[source,yaml]
----
apiVersion: cluster.redpanda.com/v1alpha2
kind: Schema
metadata:
  name: protobuf-schema
  namespace: redpanda
spec:
  cluster:
    clusterRef:
      name: basic
  schemaType: protobuf
  text: |
    syntax = "proto3";

    message Product {
      int32 ProductID = 1;
      string ProductName = 2;
      double Price = 3;
      string Category = 4;
    }
----

For JSON Schema, specify the schema type directly within the `text` field:

[source,yaml]
----
apiVersion: cluster.redpanda.com/v1alpha2
kind: Schema
metadata:
  name: example-json-schema
  namespace: redpanda
spec:
  cluster:
    clusterRef:
      name: basic
  compatibilityLevel: Backward
  text: |
    {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "type": "object",
      "properties": {
        "name": { "type": "string" }
      },
      "required": ["name"],
      "additionalProperties": false
    }
----

The `$schema` attribute specifies the JSON Schema version, allowing you to choose the best version for your use case. Redpanda supports https://json-schema.org/specification[all published JSON Schema specifications^].

== Update a schema

To update a schema, modify the Schema resource, for example, by adding a new field:

[source,yaml]
----
apiVersion: cluster.redpanda.com/v1alpha2
kind: Schema
metadata:
  name: <topic-name>
  namespace: <namespace>
spec:
  cluster:
    clusterRef:
      name: <cluster-name>
  text: |
    {
      "type": "record",
      "name": "test",
      "fields": [
        { "type": "string", "name": "field1" },
        { "type": "int", "name": "field2" },
        { "type": "int", "name": "field3", "default": 0 }
      ]
    }
----

Apply the updated schema:

[source,bash]
----
kubectl apply -f <updated-schema-manifest>.yaml --namespace redpanda
----

== Check schema version

Ensure the schema has been versioned by running:

[source,bash]
----
kubectl get schema --namespace <namespace>
----

You can check specific versions of the schema:

[source,bash]
----
kubectl exec -it --namespace <namespace> <pod-name> -- curl https://<pod-name>.<cluster-name>.<namespace>.svc.cluster.local:8081/schemas/ids/1 -sS --cacert /etc/tls/certs/default/ca.crt -w '\n'
kubectl exec -it --namespace <namespace> <pod-name> -- curl https://<pod-name>.<cluster-name>.<namespace>.svc.cluster.local:8081/schemas/ids/2 -sS --cacert /etc/tls/certs/default/ca.crt -w '\n'
----

== Delete a schema

To delete a schema, use the following command:

[source,bash]
----
kubectl delete schema mytopic-value --namespace redpanda
----

Verify cleanup by checking the Redpanda schema registry:

[source,bash]
----
kubectl exec -it --namespace <namespace> <pod-name> -- curl https://<pod-name>.<cluster-name>.<namespace>.svc.cluster.local:8081/subjects -sS --cacert /etc/tls/certs/default/ca.crt -w '\n'
----

== Next steps

For more details on using schemas in Redpanda, see:

* xref:manage:schema-reg/schema-reg-api.adoc[Schema Registry API documentation]
* xref:manage:schema-reg/schema-reg-ui.adoc[Schema Registry UI documentation]
* xref:manage:schema-reg/record-deserialization.adoc[Data deserialization guide]

These resources provide further insights into Redpandaâ€™s Schema Registry features, helping you make the most of schema management in your Redpanda deployment.

