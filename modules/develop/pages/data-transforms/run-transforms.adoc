= Run Data Transforms
:description: Learn how to build and deploy data transforms in Redpanda.
:page-aliases: reference:rpk/rpk-wasm/rpk-wasm.adoc, reference:rpk/rpk-wasm.adoc, reference:rpk/rpk-wasm/rpk-wasm-deploy.adoc, reference:rpk/rpk-wasm/rpk-wasm-generate.adoc, reference:rpk/rpk-wasm/rpk-wasm-remove.adoc, data-management:data-transform.adoc
:latest-data-transforms-version: 0.0.0-20230830git604fcce

Data transforms let you run common data streaming tasks, like filtering, scrubbing, and transcoding, within Redpanda. For example, you may have consumers that require you to remove credit card numbers or convert JSON to Avro. Data transforms can also interact with the Redpanda Schema Registry to work with encoded data types. 

Data transforms use a WebAssembly (Wasm) engine inside a Redpanda broker. A Wasm function acts on a single record in an input topic. You can develop and manage data transforms with `rpk transform` commands.

See also: xref:./how-transforms-work.adoc[] and <<Limitations>>

== Enable data transforms

. To enable data transforms, set the `data_transforms_enabled` cluster configuration flag:
+
```bash
rpk cluster config set data_transforms_enabled true
```
. Restart the broker with `rpk redpanda stop`, then `rpk redpanda start`. This property requires the cluster to be restarted in order to be applied.

== Create a data transforms project

. Create and initialize a data transforms project:
+
```bash
rpk transform init
```
+
A successful command generates project files in your current directory:
+
[.no-copy]
----
.
├── go.mod
├── go.sum
├── README.md
├── transform.go
└── transform.yaml
----
+
The `transform.go` file contains the transform logic, and the `transform.yaml` file configures the project.
+
TIP: When creating a custom data transform, initialization steps can be done either in `main` (because it's only run once at the start of the package) or in Go's standard predefined `init()` function. Although state can be cached in global variables, Redpanda may restart a Wasm module at any point, which causes the state to be lost.

. Implement your project by adding transform logic to `transform.go`. 
+
The following examples show some basic transforms. Each example can be copied into the `transform.go` file.
+
[tabs]
====
Identity transform::
+
--
```go
package main

import (
	"github.com/redpanda-data/redpanda/src/go/transform-sdk"
)

// This example shows the basic usage of the package:
// This transform does nothing but copy the same data from an
// input topic to an output topic.
func main() {
	// Make sure to register your callback and perform other setup in main
	redpanda.OnRecordWritten(identityTransform)
}

// This will be called for each record in the source topic.
//
// The output records returned will be written to the destination topic.
func identityTransform(e redpanda.WriteEvent) ([]redpanda.Record, error) {
	return []redpanda.Record{e.Record()}, nil
}
```
--
Transcoder transform::
+
--

```go
package main

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	"errors"
	"io"
	"strconv"

	"github.com/redpanda-data/redpanda/src/go/transform-sdk"
)

// This example shows a transform that converts CSV inputs into JSON outputs.
func main() {
	redpanda.OnRecordWritten(csvToJsonTransform)
}

type Foo struct {
	A string `json:"a"`
	B int    `json:"b"`
}

func csvToJsonTransform(e redpanda.WriteEvent) ([]redpanda.Record, error) {
	// The input data is a CSV (without a header row) that is the structure of:
	// key, a, b
	reader := csv.NewReader(bytes.NewReader(e.Record().Value))
	// Improve performance by reusing the result slice.
	reader.ReuseRecord = true
	output := []redpanda.Record{}
	for {
		row, err := reader.Read()
		if err == io.EOF {
			break
		} else if err != nil {
			return nil, err
		}
		if len(row) != 3 {
			return nil, errors.New("unexpected number of rows")
		}
		// Convert the last column into an int
		b, err := strconv.Atoi(row[2])
		if err != nil {
			return nil, err
		}
		// Marshal our JSON value
		f := Foo{
			A: row[1],
			B: b,
		}
		v, err := json.Marshal(&f)
		if err != nil {
			return nil, err
		}
		// Add our output record using the first column as the key.
		output = append(output, redpanda.Record{
			Key:   []byte(row[0]),
			Value: v,
		})

	}
	return output, nil
}
```

--
Validation filter transform::
+
--
```go
import (
	"encoding/json"

	"github.com/redpanda-data/redpanda/src/go/transform-sdk"
)

// This example shows a filter that outputs only valid JSON into the
// output topic.
func main() {
	redpanda.OnRecordWritten(filterValidJson)
}

func filterValidJson(e redpanda.WriteEvent) ([]redpanda.Record, error) {
	v := []redpanda.Record{}
	if json.Valid(e.Record().Value) {
		v = append(v, e.Record())
	}
	return v, nil
}
```

--
====

== Build and deploy the transform

. Build the transform into a Wasm module with metadata: 
+
```bash
rpk transform build
```

. Deploy the Wasm module to your cluster. For example:
+
```bash
rpk transform deploy --input-topic=demo-1 --output-topic=demo-2
```

. Validate that your transform is running. For example:
.. Produce a few records to the `demo-1` topic.
+
```bash
echo "foo\nbar" | rpk topic produce demo-1
```
.. Consume from the `demo-2` topic.
+
```bash
rpk topic consume demo-2
```
+
[,json,role="no-copy"]
----
{
  "topic": "demo-2",
  "value": "foo",
  "timestamp": 1687545891433,
  "partition": 0,
  "offset": 0
}

  "topic": "demo-2",
  "value": "bar",
  "timestamp": 1687545892434,
  "partition": 0,
  "offset": 1
}
----

NOTE: You can see `stdout` and `stderr` for your function in the broker's logs. 

== Limitations

- Transforms have no external access to disk or network resources. 
- Only single record transforms are supported, not aggregations or joins. For complex transformations, use Apache Flink.
- Only a single output topic is supported.
- Transforms have at-least-once delivery.
- Because data transforms are powered by Wasm, transform functions can be authored in any language. However, a data transforms SDK currently is only available in xref:reference:data-transform-api.adoc[Golang]. 

== Related topics

- xref:./how-transforms-work.adoc[]
- xref:reference:data-transform-api.adoc[]
- rpk transform **(link when we pull code include in Beta docs rpk section)**
