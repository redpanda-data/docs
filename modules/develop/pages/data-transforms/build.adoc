= Develop Data Transforms
:description: Learn how to initialize a data transforms project and write transform functions in your chosen language.
:page-categories: Development, Stream Processing, Data Transforms
:page-topic-type: how-to
:personas: streaming_developer, application_developer
:learning-objective-1: Initialize a data transforms project with the rpk CLI
:learning-objective-2: Build transform functions that process records and write to output topics
:learning-objective-3: Implement multi-topic routing patterns with Schema Registry integration
// tag::single-source[]

{description}

== Prerequisites

You must have the following development tools installed on your host machine:

ifdef::env-cloud[]
* The xref:manage:rpk/rpk-install.adoc[`rpk` command-line client] installed.
endif::[]
ifndef::env-cloud[]
* The xref:get-started:rpk-install.adoc[`rpk` command-line client] installed on your host machine and configured to connect to your Redpanda cluster.
endif::[] 
* For Golang projects, you must have at least version 1.20 of https://go.dev/doc/install[Go^].
* For Rust projects, you must have the latest stable version of https://rustup.rs/[Rust^].
* For JavaScript and TypeScript projects, you must have the https://nodejs.org/en/download/package-manager[latest long-term-support release of Node.js^].

ifdef::env-cloud[]
== Enable data transforms

Data transforms are disabled on all clusters by default. Before you can deploy data transforms to a cluster, you must first enable the feature with the `rpk` command-line tool. To enable data transforms, set the xref:reference:properties/cluster-properties.adoc#data_transforms_enabled[`data_transforms_enabled`] cluster property to `true`:

[source,bash]
----
rpk cluster config set data_transforms_enabled true
----

NOTE: This property requires a rolling restart, and it can take several minutes for the update to complete.

endif::[]


[[init]]
== Initialize a data transforms project

To initialize a data transforms project, use the following command to set up the project files in your current directory. This command adds the latest version of the xref:reference:data-transforms/sdks.adoc[SDK] as a project dependency:

[source,bash]
----
rpk transform init --language=<language> --name=<name>
----

If you do not include the `--language` flag, the command will prompt you for the language. Supported languages include:

* `tinygo-no-goroutines` (does not include https://golangdocs.com/goroutines-in-golang[Goroutines])
* `tinygo-with-goroutines`
* `rust`
* `javascript`
* `typescript`

For example, if you choose `tinygo-no-goroutines`, the following project files are created:

[.no-copy]
----
.
├── go.mod
├── go.sum
├── README.md
├── transform.go
└── transform.yaml
----

The `transform.go` file contains a boilerplate transform function.
The `transform.yaml` file specifies the configuration settings for the transform function.

See also: xref:develop:data-transforms/configure.adoc[]

== Build transform functions

You can develop your transform logic with one of the available SDKs that allow your transform code to interact with a Redpanda cluster.

[tabs]
======
Go::
+
--
All transform functions must register a callback with the `OnRecordWritten()` method.

You should run any initialization steps in the `main()` function because it's only run once when the transform function is first deployed. You can also use the standard predefined https://go.dev/doc/effective_go#init[`init()` function].

[source,go]
----
package main

import (
	"github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
)

func main() {
  // Register your transform function.
  // This is a good place to perform other setup too.
  transform.OnRecordWritten(myTransform)
}
// myTransform is where you read the record that was written, and then you can
// output new records that will be written to the destination topic
func myTransform(event transform.WriteEvent, writer transform.RecordWriter) error {
  return writer.Write(event.Record())
}
----
--
Rust::
+
--
All transform functions must register a callback with the `on_record_written()` method.

You should run any initialization steps in the `main()` function because it's only run once when the transform function is first deployed.

[source,rust]
----
use redpanda_transform_sdk::*;

fn main() {
  // Register your transform function.
  // This is a good place to perform other setup too.
  on_record_written(my_transform);
}

// my_transform is where you read the record that was written, and then you can
// return new records that will be written to the output topic
fn my_transform(event: WriteEvent, writer: &mut RecordWriter) -> Result<(), Box<dyn Error>> {
  writer.write(event.record)?;
  Ok(())
}
----
--
JavaScript::
+
--
All transform functions must register a callback with the `onRecordWritten()` method.

You should run any initialization steps outside of the callback so that they are only run once when the transform function is first deployed.

[source,js]
----
// src/index.js
import { onRecordWritten } from "@redpanda-data/transform-sdk";

// This is a good place to perform setup steps.

// Register your transform function.
onRecordWritten((event, writer) => {
  // This is where you read the record that was written, and then you can
  // output new records that will be written to the destination topic
  writer.write(event.record);
});
----

If you need to use Node.js standard modules in your transform function, you must configure the https://github.com/cyco130/esbuild-plugin-polyfill-node[`polyfillNode` plugin] for https://esbuild.github.io/[esbuild^]. This plugin allows you to polyfill Node.js APIs that are not natively available in the Redpanda JavaScript runtime environment.

.`esbuild.js`
[source,js]
----
import * as esbuild from 'esbuild';
import { polyfillNode } from 'esbuild-plugin-polyfill-node';

await esbuild.build({
  plugins: [
    polyfillNode({
      globals: {
        buffer: true, // Allow a global Buffer variable if referenced.
        process: false, // Don't inject the process global, the Redpanda JavaScript runtime does that.
      },
      polyfills: {
        crypto: true, // Enable crypto polyfill
        // Add other polyfills as needed
      },
    }),
  ],
});
----
--
======

[[errors]]
=== Error handling

By distinguishing between recoverable and critical errors, you can ensure that your transform functions are both resilient and robust. Handling recoverable errors internally helps maintain continuous operation, while allowing critical errors to escape ensures that the system can address severe issues effectively.

Redpanda tracks the offsets of records that have been processed by transform functions. If an error escapes the Wasm virtual machine (VM), the VM will fail. When the Wasm engine detects this failure and starts a new VM, the transform function will retry processing the input topics from the last processed offset, potentially leading to repeated failures if the underlying issue is not resolved.

Handling errors internally by logging them and continuing to process subsequent records can help maintain continuous operation. However, this approach can result in silently discarding problematic records, which may lead to unnoticed data loss if the logs are not monitored closely.

[tabs]
======
Go::
+
--
[source,go]
----
package main

import (
    "log"
    "github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
)

func main() {
    transform.OnRecordWritten(myTransform)
}

func myTransform(event transform.WriteEvent, writer transform.RecordWriter) error {
  record := event.Record()
  if record.Key == nil {
    // Handle the error internally by logging it
    log.Println("Error: Record key is nil")
    // Skip this record and continue to process other records
    return nil
  }
  // Allow errors with writes to escape
  return writer.Write(record)
}
----
--
Rust::
+
--
[source,rust]
----
use redpanda_transform_sdk::*;
use log::error;

fn main() {
  // Set up logging
  env_logger::init();
  on_record_written(my_transform);
}

fn my_transform(event: WriteEvent, writer: &mut RecordWriter) -> anyhow::Result<()> {
  let record = event.record;
  if record.key().is_none() {
    // Handle the error internally by logging it
    error!("Error: Record key is nil");
    // Skip this record and continue to process other records
    return Ok(());
  }
  // Allow errors with writes to escape
  return writer.write(record)
}
----
--
JavaScript::
+
--

[source,js]
----
import { onRecordWritten } from "@redpanda-data/transform-sdk";

// Register your transform function.
onRecordWritten((event, writer) => {
  const record = event.record;
  if (!record.key) {
    // Handle the error internally by logging it
    console.error("Error: Record key is nil");
    // Skip this record and continue to process other records
    return;
  }
  // Allow errors with writes to escape
  writer.write(record);
});

----
--
======

When you deploy this transform function, and produce a message without a key, you'll get the following in the logs:

[source,js,role="no-copy"]
----
{
  "body": {
    "stringValue": "2024/06/20 08:17:33 Error: Record key is nil\n"
  },
  "timeUnixNano": 1718871455235337000,
  "severityNumber": 13,
  "attributes": [
    {
      "key": "transform_name",
      "value": {
        "stringValue": "test"
      }
    },
    {
      "key": "node",
      "value": {
        "intValue": 0
      }
    }
  ]
}
----

You can view logs for transform functions using the `rpk transform logs <transform-function-name>` command.

To ensure that you are notified of any errors or issues in your data transforms, Redpanda provides metrics that you can use to monitor the state of your data transforms.

See also:

- xref:develop:data-transforms/monitor#logs[View logs for transform functions]
- xref:develop:data-transforms/monitor.adoc[Monitor data transforms]
- xref:develop:data-transforms/configure.adoc#log[Configure transform logging]
- xref:reference:rpk/rpk-transform/rpk-transform-logs.adoc[`rpk transform logs` reference]

=== Avoid state management

Relying on in-memory state across transform invocations can lead to inconsistencies and unpredictable behavior. Data transforms operate with at-least-once semantics, meaning a transform function might be executed more than once for a given record. Redpanda may also restart a transform function at any point, which causes its state to be lost.

[[env-vars]]
=== Access environment variables

You can access both xref:develop:data-transforms/configure.adoc#environment-variables[built-in and custom environment variables] in your transform function. In this example, environment variables are checked once during initialization:

[tabs]
======
Go::
+
--
[source,go]
----
package main

import (
  "fmt"
  "os"
	"github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
)

func main() {
  // Check environment variables before registering the transform function.
  outputTopic1, ok := os.LookupEnv("REDPANDA_OUTPUT_TOPIC_1")
  if ok {
    fmt.Printf("Output topic 1: %s\n", outputTopic1)
  } else {
    fmt.Println("Only one output topic is set")
  }

  // Register your transform function.
  transform.OnRecordWritten(myTransform)
}

func myTransform(event transform.WriteEvent, writer transform.RecordWriter) error {
  return writer.Write(event.Record())
}
----
--
Rust::
+
--
[source,rust]
----
use redpanda_transform_sdk::*;
use std::env;
use log::error;

fn main() {
  // Set up logging
  env_logger::init();

  // Check environment variables before registering the transform function.
  match env::var("REDPANDA_OUTPUT_TOPIC_1") {
    Ok(output_topic_1) => println!("Output topic 1: {}", output_topic_1),
    Err(_) => println!("Only one output topic is set"),
  }

  // Register your transform function.
  on_record_written(my_transform);
}

fn my_transform(_event: WriteEvent, _writer: &mut RecordWriter) -> anyhow::Result<()> {
  Ok(())
}
----
--
JavaScript::
+
--

[source,js]
----
import { onRecordWritten } from "@redpanda-data/transform-sdk";

// Check environment variables before registering the transform function.
const outputTopic1 = process.env.REDPANDA_OUTPUT_TOPIC_1;
if (outputTopic1) {
  console.log(`Output topic 1: ${outputTopic1}`);
} else {
  console.log("Only one output topic is set");
}

// Register your transform function.
onRecordWritten((event, writer) => {
  return writer.write(event.record);
});
----
--
======

=== Write to specific output topics

You can configure your transform function to write records to specific output topics based on message content, enabling powerful routing and fan-out patterns. This capability is useful for:

* Filtering messages by criteria and routing to different topics
* Fan-out patterns that distribute data from one input topic to multiple output topics
* Event routing based on message type or schema
* Data distribution for downstream consumers

Wasm transforms provide a simpler alternative to external connectors like Kafka Connect for in-broker data routing, with lower latency and no additional infrastructure to manage.

==== Basic JSON validation example

The following example shows a filter that outputs only valid JSON from the input topic into the output topic. Invalid JSON is written to a different output topic.

[tabs]
======
Go::
+
--
[source,go]
----
import (
	"encoding/json"
	"github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
)

func main() {
	transform.OnRecordWritten(filterValidJson)
}

func filterValidJson(event transform.WriteEvent, writer transform.RecordWriter) error {
	if json.Valid(event.Record().Value) {
		return writer.Write(event.Record())
	}
	// Send invalid records to separate topic
	return writer.Write(event.Record(), transform.ToTopic("invalid-json"))
}
----
--
Rust::
+
--
[source,rust]
----
use anyhow::Result;
use redpanda_transform_sdk::*;

fn main() {
	on_record_written(filter_valid_json);
}

fn filter_valid_json(event: WriteEvent, writer: &mut RecordWriter) -> Result<()> {
	let value = event.record.value().unwrap_or_default();
	if serde_json::from_slice::<serde_json::Value>(value).is_ok() {
		writer.write(event.record)?;
	} else {
		// Send invalid records to separate topic
		writer.write_with_options(event.record, WriteOptions::to_topic("invalid-json"))?;
	}
	Ok(())
}
----
--
JavaScript::
+
--
The JavaScript SDK does not support writing records to a specific output topic.

--
======

[[multi-topic-fanout]]
==== Multi-topic fan-out with Schema Registry

This example routes batched updates from a single input topic to multiple output topics based on a routing field in each message. Messages are encoded with the xref:manage:schema-reg/schema-reg-overview.adoc#wire-format[Schema Registry wire format] for validation against the output topic schema. Consider using this pattern with Iceberg-enabled topics to fan out data directly into lakehouse tables.

.Input message example
[,json]
----
{
  "updates": [
    {"table": "orders", "data": {"order_id": "123", "amount": 99.99}},
    {"table": "inventory", "data": {"product_id": "P456", "quantity": 50}},
    {"table": "customers", "data": {"customer_id": "C789", "name": "Jane"}}
  ]
}
----

xref:develop:data-transforms/configure.adoc[Configure the transform] with multiple output topics:

[,yaml]
----
name: event-router
input_topic: events
output_topics:
  - orders
  - inventory
  - customers
----

The transform extracts each update and routes it to the appropriate topic based on the `table` field. In this example, it is assumed that you have created each output topic and registered the corresponding schemas in Schema Registry.

NOTE: xref:manage:schema-reg/schema-reg-api.adoc[Register schemas in Schema Registry] before deploying the transform. The schema IDs in the code examples must match the IDs returned by Schema Registry during registration. Use the `{topic-name}-value` naming convention for schema subjects (for example, `orders-value`, `inventory-value`).

[tabs]
======
Go::
+
--
.`go.mod`
[%collapsible]
====
[,go]
----
module fanout-example

go 1.20

require github.com/redpanda-data/redpanda/src/transform-sdk/go/transform v1.1.0 // v1.1.0+ required
----
====

`transform.go`:

[,go]
----
package main

import (
    "encoding/binary"
    "encoding/json"
    "log"
    "github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
)

// Input message structure with array of updates
type BatchMessage struct {
    Updates []TableUpdate `json:"updates"`
}

// Individual table update with routing field
type TableUpdate struct {
    Table string          `json:"table"` // Routing field - determines output topic
    Data  json.RawMessage `json:"data"`  // The actual data to write
}

// Schema IDs for each output topic obtained from Schema Registry
// Register schemas before deploying the transform using the {topic-name}-value naming convention
var schemaIDs = map[string]int{
    "orders":    1,
    "inventory": 2,
    "customers": 3,
}

func main() {
    log.Printf("Starting fanout transform with schema IDs: %v", schemaIDs)
    transform.OnRecordWritten(routeUpdates)
}

func routeUpdates(event transform.WriteEvent, writer transform.RecordWriter) error {
    var batch BatchMessage
    if err := json.Unmarshal(event.Record().Value, &batch); err != nil {
        log.Printf("Failed to parse batch message: %v", err)
        return nil // Skip invalid records
    }

    // Process each update in the batch
    for i, update := range batch.Updates {
        schemaID, exists := schemaIDs[update.Table]
        if !exists {
            log.Printf("Unknown table in update %d: %s", i, update.Table)
            continue
        }

        if err := writeUpdate(update, schemaID, writer, event); err != nil {
            log.Printf("Failed to write update %d to %s: %v", i, update.Table, err)
        }
    }

    return nil
}

func writeUpdate(update TableUpdate, schemaID int, writer transform.RecordWriter, event transform.WriteEvent) error {
    // Create Schema Registry wire format: [magic_byte, schema_id (4 bytes BE), data...]
    value := make([]byte, 5)
    value[0] = 0 // magic byte
    binary.BigEndian.PutUint32(value[1:5], uint32(schemaID))
    value = append(value, update.Data...)

    record := transform.Record{
        Key:   event.Record().Key,
        Value: value,
    }

    return writer.Write(record, transform.ToTopic(update.Table))
}
----
--

Rust::
+
--
.`Cargo.toml`
[%collapsible]
====
[,toml]
----
[package]
name = "fanout-rust-example"
version = "0.1.0"
edition = "2021"

[dependencies]
redpanda-transform-sdk = "1.1.0"  # v1.1.0+ required for WriteOptions API
serde = { version = "1", features = ["derive"] }
serde_json = "1"

[profile.release]
opt-level = "z"
lto = true
strip = true
----
====

`src/main.rs`:

[,rust]
----
use redpanda_transform_sdk::*;
use serde::Deserialize;
use std::collections::HashMap;
use std::error::Error;

#[derive(Deserialize)]
struct BatchMessage {
    updates: Vec<TableUpdate>,
}

#[derive(Deserialize)]
struct TableUpdate {
    table: String,
    data: serde_json::Value,
}

// Schema IDs for each output topic obtained from Schema Registry
// Register schemas before deploying the transform using the {topic-name}-value naming convention
static mut SCHEMA_IDS: Option<HashMap<String, i32>> = None;

fn main() {
    let mut schema_ids = HashMap::new();
    schema_ids.insert("orders".to_string(), 1);
    schema_ids.insert("inventory".to_string(), 2);
    schema_ids.insert("customers".to_string(), 3);

    unsafe {
        SCHEMA_IDS = Some(schema_ids);
    }

    on_record_written(route_updates);
}

fn write_update(
    update: &TableUpdate,
    schema_id: i32,
    writer: &mut RecordWriter,
    event: &WriteEvent,
) -> Result<(), Box<dyn Error>> {
    // Create Schema Registry wire format: [magic_byte, schema_id (4 bytes BE), data...]
    let mut value = vec![0u8; 5];
    value[0] = 0; // magic byte
    value[1..5].copy_from_slice(&schema_id.to_be_bytes());

    let data_bytes = serde_json::to_vec(&update.data)?;
    value.extend_from_slice(&data_bytes);

    let key = event.record.key().map(|k| k.to_vec());
    let record = BorrowedRecord::new(key.as_deref(), Some(&value));

    writer.write_with_options(record, WriteOptions::to_topic(&update.table))?;
    Ok(())
}

fn route_updates(event: WriteEvent, writer: &mut RecordWriter) -> Result<(), Box<dyn Error>> {
    let batch: BatchMessage = serde_json::from_slice(event.record.value().unwrap_or_default())?;
    let schema_ids = unsafe { SCHEMA_IDS.as_ref().unwrap() };

    for update in batch.updates.iter() {
        if let Some(&schema_id) = schema_ids.get(&update.table) {
            write_update(update, schema_id, writer, &event)?;
        }
    }

    Ok(())
}
----
--

JavaScript::
+
--
The JavaScript SDK does not support writing records to specific output topics. For multi-topic fan-out, use the Go or Rust SDK.
--
======

=== Connect to the Schema Registry

You can use the Schema Registry client library to read and write schemas as well as serialize and deserialize records. This client library is useful when working with schema-based topics in your data transforms.

See also:

- xref:manage:schema-reg/schema-reg-overview.adoc[]
- xref:reference:data-transforms/golang-sdk.adoc[Go Schema Registry client reference]
- xref:reference:data-transforms/rust-sdk.adoc[Rust Schema Registry client reference]
- xref:reference:data-transforms/js/js-sdk-sr.adoc[JavaScript Schema Registry client reference]

== Next steps

xref:develop:data-transforms/configure.adoc[]

== Suggested reading

- xref:develop:data-transforms/how-transforms-work.adoc[]
- xref:reference:data-transforms/sdks.adoc[]
- xref:reference:rpk/rpk-transform/rpk-transform.adoc[`rpk transform` commands]

// end::single-source[]