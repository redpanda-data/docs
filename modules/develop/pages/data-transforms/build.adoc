= Develop Data Transforms
:description: Learn how to initialize a data transforms project and write transform functions in your chosen language.
:page-categories: Development, Stream Processing, Data Transforms

{description}

== Prerequisites

You must have the following development tools installed on your host machine:

* For Golang, you must have at least version 1.20 of https://go.dev/doc/install[Go^].
* For Rust, you must have the latest stable version of https://rustup.rs/[Rust].
* The xref:get-started:rpk-install.adoc[`rpk` command-line client] installed on your host machine and configured to connect to your Redpanda cluster.

[[init]]
== Initialize a data transforms project

To initialize a data transforms project, use the following command to set up the project files in your current directory. This command adds the latest version of the xref:reference:data-transforms/sdks.adoc[SDK] as a project dependency:

[source,bash]
----
rpk transform init --language=<language> --name=<name>
----

If you do not include the `--language` flag, the command will prompt you for the language. Supported languages include:

* `tinygo-no-goroutines` (does not include https://golangdocs.com/goroutines-in-golang[Goroutines])
* `tinygo-with-goroutines`
* `rust`

For example, if you choose `tinygo-no-goroutines`, the following project files are created:

[.no-copy]
----
.
├── go.mod
├── go.sum
├── README.md
├── transform.go
└── transform.yaml
----

The `transform.go` file contains a boilerplate transform function.
The `transform.yaml` file specifies the configuration settings for the transform function.

See also:

- xref:develop:data-transforms/configure.adoc[]

== Build transform functions

You can develop your transform logic with one of the available SDKs that allow your transform code to interact with a Redpanda cluster.

[tabs]
======
Go::
+
--
All transform functions must register a callback with the `OnRecordWritten()` method.

[source,go]
----
package main

import (
	"github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
)

func main() {
  // Register your transform function.
  // This is a good place to perform other setup too.
  transform.OnRecordWritten(myTransform)
}
// myTransform is where you read the record that was written, and then you can
// output new records that will be written to the destination topic
func myTransform(event transform.WriteEvent, writer transform.RecordWriter) error {
  return writer.Write(event.Record())
}
----
--
Rust::
+
--
All transform functions must register a callback with the `on_record_written()` method.

[source,rust]
----
use redpanda_transform_sdk::*;

fn main() {
  // Register your transform function.
  // This is a good place to perform other setup too.
  on_record_written(my_transform);
}

// my_transform is where you read the record that was written, and then you can
// return new records that will be written to the output topic
fn my_transform(event: WriteEvent, writer: &mut RecordWriter) -> Result<(), Box<dyn Error>> {
  writer.write(event.record)?;
  Ok(())
}
----
--
======

When creating a transform function, you should run any initialization steps in the `main()` function because it's only run once when the transform function is first deployed. If you're using Go, you can also use the standard predefined https://go.dev/doc/effective_go#init[`init()` function].

[[errors]]
=== Error handling

By distinguishing between recoverable and critical errors, you can ensure that your transform functions are both resilient and robust. Handling recoverable errors internally helps maintain continuous operation, while allowing critical errors to escape ensures that the system can address severe issues effectively.

Redpanda tracks the offsets of records that have been processed by transform functions. If an error escapes the Wasm virtual machine (VM), the VM will fail. When the Wasm engine detects this failure and starts a new VM, the transform function will retry processing the input topics from the last processed offset, potentially leading to repeated failures if the underlying issue is not resolved.

Handling errors internally by logging them and continuing to process subsequent records can help maintain continuous operation. However, this approach can result in silently discarding problematic records, which may lead to unnoticed data loss if the logs are not monitored closely.

==== Allow errors to escape

Allow errors to escape the Wasm VM only when they indicate a problem with the Redpanda infrastructure or the Wasm engine environment. Allowing the error to propagate ensures that the system can attempt to recover by restarting the VM and processing from the last committed offset.

[tabs]
======
Go::
+
--
[source,go]
----
package main

import (
    "log"
    "github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
)

func main() {
    transform.OnRecordWritten(myTransform)
}

func myTransform(event transform.WriteEvent, writer transform.RecordWriter) error {
  err := writer.Write(event.Record())
  if err != nil {
    log.Println("Error writing record:", err)
  }
  // If err is non-nil, it will fail the VM
  return err
}
----
--
Rust::
+
--
[source,rust]
----
use redpanda_transform_sdk::*;
use log::error;

fn main() {
  // Set up logging
  env_logger::init();
  on_record_written(my_transform);
}

fn my_transform(event: WriteEvent, writer: &mut RecordWriter) -> anyhow::Result<()> {
  let record = event.record;
  if let Err(err) = writer.write(record) {
    // Log the error
    error!("Error writing record: {}", err);
    // Return the error to propagate it
    return Err(err.into());
  }

  // Return OK if no error occurred
  Ok(())
}
----
--
======

To ensure that you are notified of any errors or issues in your data transforms, Redpanda provides metrics that you can use to monitor the state of your data transforms. See xref:develop:data-transforms/monitor.adoc[Monitor data transforms].

==== Handle errors internally

Use this approach for recoverable errors that can be logged and skipped without stopping the entire transform process. This ensures that processing continues for subsequent records, but requires careful monitoring of logs to detect and address any issues.

[tabs]
======
Go::
+
--
[source,go]
----
package main

import (
    "log"
    "github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
)

func main() {
    transform.OnRecordWritten(myTransform)
}

func myTransform(event transform.WriteEvent, writer transform.RecordWriter) error {
  record := event.Record()
  if record.Key == nil {
    // Log the error and continue processing
    log.Println("Error: Record key is nil")
    // Skip this record
    return nil
  }

  return writer.Write(record)
}
----
--
Rust::
+
--
[source,rust]
----
use redpanda_transform_sdk::*;
use log::error;

fn main() {
  // Set up logging
  env_logger::init();
  on_record_written(my_transform);
}

fn my_transform(event: WriteEvent, writer: &mut RecordWriter) -> anyhow::Result<()> {
  let record = event.record;
  if record.key().is_none() {
    // Log the error and continue processing
    error!("Error: Record key is nil");
    // Skip this record
    return Ok(());
  }

  return writer.write(record)
}
----
--
======

When you deploy this transform function, and produce a message without a key, you'll get the following in the logs:

[source,js,role="no-copy"]
----
{
  "body": {
    "stringValue": "2024/06/20 08:17:33 Error: Record key is nil\n"
  },
  "timeUnixNano": 1718871455235337000,
  "severityNumber": 13,
  "attributes": [
    {
      "key": "transform_name",
      "value": {
        "stringValue": "test"
      }
    },
    {
      "key": "node",
      "value": {
        "intValue": 0
      }
    }
  ]
}
----

You can view logs for transform functions using the `rpk transform logs <transform-function-name>` command.

See also:

- xref:develop:data-transforms/monitor#logs[View logs for transform functions]
- xref:develop:data-transforms/configure.adoc#log[Configure transform logging]
- xref:reference:rpk/rpk-transform/rp-transform-logs[]

=== Avoid state management

Relying on in-memory state across transform invocations can lead to inconsistencies and unpredictable behavior. Data transforms operate with at-least-once semantics, meaning a transform function might be executed more than once for a given record. Redpanda may also restart a transform function at any point, which causes its state to be lost.

[[env-vars]]
=== Access environment variables

You can access both xref:develop:data-transforms/configure.adoc#environment-variables[built-in and custom environment variables] in your transform function. In this example, the environment variables are checked once during initialization:

[tabs]
======
Go::
+
--
[source,go]
----
package main

import (
  "fmt"
  "os"
	"github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
)

func main() {
  // Check environment variables before registering the transform function.
  inputTopic, ok := os.LookupEnv("REDPANDA_INPUT_TOPIC")
  if ok {
    fmt.Printf("Input topic: %s\n", inputTopic)
  } else {
    fmt.Println("An input topic is not set")
  }

  outputTopic0, ok := os.LookupEnv("REDPANDA_OUTPUT_TOPIC_0")
  if ok {
    fmt.Printf("Output topic 0: %s\n", outputTopic0)
  } else {
    fmt.Println("An output topic is not set")
  }

  outputTopic1, ok := os.LookupEnv("REDPANDA_OUTPUT_TOPIC_1")
  if ok {
    fmt.Printf("Output topic 1: %s\n", outputTopic1)
  } else {
    fmt.Println("Only one output topic is set")
  }

  // Register your transform function.
  transform.OnRecordWritten(myTransform)
}

func myTransform(event transform.WriteEvent, writer transform.RecordWriter) error {
  return writer.Write(event.Record())
}
----
--
Rust::
+
--
[source,rust]
----
use redpanda_transform_sdk::*;
use std::env;
use log::error;

fn main() {
  // Set up logging
  env_logger::init();

  // Check environment variables before registering the transform function.
  match env::var("REDPANDA_INPUT_TOPIC") {
    Ok(input_topic) => println!("Input topic: {}", input_topic),
    Err(_) => println!("An input topic is not set"),
  }

  match env::var("REDPANDA_OUTPUT_TOPIC_0") {
    Ok(output_topic_0) => println!("Output topic 0: {}", output_topic_0),
    Err(_) => println!("An output topic is not set"),
  }

  match env::var("REDPANDA_OUTPUT_TOPIC_1") {
    Ok(output_topic_1) => println!("Output topic 1: {}", output_topic_1),
    Err(_) => println!("Only one output topic is set"),
  }

  // Register your transform function.
  on_record_written(my_transform);
}

fn my_transform(_event: WriteEvent, _writer: &mut RecordWriter) -> anyhow::Result<()> {
  Ok(())
}
----
--
======

=== Connect to the Schema Registry

You can use the Schema Registry client library to read and write schemas as well as serialize and deserialize records. This client library is useful when working with schema-based topics in your data transforms.

See also:

- xref:manage:schema-reg/schema-reg-overview.adoc[]
- xref:reference:data-transforms/golang-sdk.adoc[Go Schema Registry client reference]
- xref:reference:data-transforms/rust-sdk.adoc[Rust Schema Registry client reference]

==== Initialize the Schema Registry client

First, initialize the Schema Registry client. This client will interact with the local Redpanda Schema Registry.

[tabs]
======
Go::
+
--
[source,go]
----
package main

import (
  "context"
  "fmt"
	"github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
	"github.com/redpanda-data/redpanda/src/transform-sdk/go/transform/sr"
)

func main() {
  client := sr.NewClient()

  // Register your transform function.
  transform.OnRecordWritten(myTransform)
}

func myTransform(event transform.WriteEvent, writer transform.RecordWriter) error {
  // Use the client...
  return writer.Write(event.Record())
}
----
--
Rust::
+
--
[source,rust]
----
use redpanda_transform_sdk::*;
use redpanda_transform_sdk_sr::{SchemaRegistryClient};

fn main() {
  // Initialize the Schema Registry client
  let client = SchemaRegistryClient::new();

  // Register your transform function.
  on_record_written(my_transform);
}

fn my_transform(_event: WriteEvent, _writer: &mut RecordWriter) -> anyhow::Result<()> {
  // Use the client
  Ok(())
}
----
--
======

==== Read schemas from the Schema Registry

Use the client to read schemas from the Schema Registry. This example demonstrates how to look up a schema by its ID.

NOTE: The Schema Registry client caches the results of schema lookups by both ID and version to avoid repeated requests to the cluster.

[tabs]
======
Go::
+
--
[source,go]
----
package main

import (
  "context"
  "fmt"
  "github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
  "github.com/redpanda-data/redpanda/src/transform-sdk/go/transform/sr"
)

func main() {
  // Initialize the Schema Registry client
  client := sr.NewClient()

  // Register your transform function.
  transform.OnRecordWritten(myTransform)
}

func myTransform(event transform.WriteEvent, writer transform.RecordWriter) error {
  // Lookup schema by ID
  schema, err := client.LookupSchemaById(1)
  if err != nil {
    panic(err)
  }

  fmt.Println("Schema:", schema.Schema)
  return writer.Write(event.Record())
}
----
--
Rust::
+
--
[source,rust]
----
use redpanda_transform_sdk::*;
use redpanda_transform_sdk_sr::{SchemaRegistryClient, SchemaId};
use anyhow::Result;

fn main() -> Result<()> {
  // Initialize the Schema Registry client
  let client = SchemaRegistryClient::new();

  // Register your transform function.
  on_record_written(|event, writer| my_transform(event, writer, &client));
}

fn my_transform(
  _event: WriteEvent,
  _writer: &mut RecordWriter,
  client: &SchemaRegistryClient,
) -> anyhow::Result<()> {
  // Lookup schema by ID
  match client.lookup_schema_by_id(SchemaId(1)) {
    Ok(schema) => {
      println!("Schema: {:?}", schema.schema());
    },
    Err(err) => {
      panic!("Failed to lookup schema: {:?}", err);
    },
  }
  Ok(())
}

----
--
======

==== Write schemas to the Schema Registry

You can also create new schemas and register them in the Schema Registry.

[tabs]
======
Go::
+
--
[source,go]
----
package main

import (
  "fmt"
	"github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
	"github.com/redpanda-data/redpanda/src/transform-sdk/go/transform/sr"
)

func main() {
  client := sr.NewClient()

  schema := sr.Schema{
    Schema: `{"type":"record","name":"MyRecord","fields":[{"name":"name","type":"string"},{"name":"age","type":"int"}]}`,
    Type: sr.TypeAvro,
  }

  subjectSchema, err := client.CreateSchema("my_subject", schema)
  if err != nil {
    println("unable to register schema: ", err)
  }

  fmt.Println("Registered new schema ID:", subjectSchema.ID)
  transform.OnRecordWritten(myTransform)
}

// Required callback, even if it does nothing
func myTransform(event transform.WriteEvent, writer transform.RecordWriter) error {
  return nil
}
----
--
Rust::
+
--
[source,rust]
----
use redpanda_transform_sdk::*;
use redpanda_transform_sdk_sr::{SchemaRegistryClient, Schema};
use anyhow::Result;

fn main() -> Result<()> {
  // Initialize the Schema Registry client
  let mut client = SchemaRegistryClient::new();

  // Define the schema
  let schema = Schema::new_avro(
    r#"{"type":"record","name":"MyRecord","fields":[{"name":"name","type":"string"},{"name":"age","type":"int"}]}"#.to_string(),
    vec![],
  );

  // Register the schema
  match client.create_schema("my_subject", schema) {
    Ok(subject_schema) => {
      println!("Registered new schema ID: {:?}", subject_schema.id());
    },
    Err(err) => {
      println!("Unable to register schema: {:?}", err);
    },
  }

  // Set up the transform function
  on_record_written(my_transform);
}

// Required callback, even if it does nothing
fn my_transform(_event: WriteEvent, _writer: &mut RecordWriter) -> Result<()> {
  Ok(())
}
----
--
======

==== Serialize records

After obtaining a schema, use it to serialize records into binary format.

[tabs]
======
Go::
+
--
[source,go]
----
package main

import (
  "fmt"
  "github.com/redpanda-data/redpanda/src/transform-sdk/go/transform"
  "github.com/redpanda-data/redpanda/src/transform-sdk/go/transform/sr"
  avro "github.com/linkedin/goavro/v2"
)

func main() {
  // Define the Avro schema as a JSON string
  schemaStr := `{"type":"record","name":"MyRecord","fields":[{"name":"name","type":"string"},{"name":"age","type":"int"}]}`

  // Create a new Avro codec using the schema
  codec, err := avro.NewCodec(schemaStr)
  if err != nil {
    panic(err) // If codec creation fails, panic
  }

  // Create a record that matches the Avro schema
  record := map[string]interface{}{
    "name": "Redpanda",
    "age":  5,
  }

  // Serialize the record into Avro binary format
  binary, err := codec.BinaryFromNative(nil, record)
  if err != nil {
    panic(err) // If serialization fails, panic
  }

  // Print the encoded binary data
  fmt.Println("Encoded binary:", binary)

  // Register a callback for handling records written to the input topic
  transform.OnRecordWritten(myTransform)
}

// Required callback, even if it does nothing
func myTransform(event transform.WriteEvent, writer transform.RecordWriter) error {
  return nil
}

----
--
Rust::
+
--
[source,rust]
----
use apache_avro::{Schema, Writer, types::Value};
use redpanda_transform_sdk::*;
use redpanda_transform_sdk_sr::{SchemaRegistryClient, Schema as RPDSchema};
use std::collections::HashMap;
use anyhow::Result;

fn main() -> Result<()> {
  // Define the schema as a string
  let schema_str = r#"{"type":"record","name":"MyRecord","fields":[{"name":"name","type":"string"},{"name":"age","type":"int"}]}"#;

  // Parse the schema string into an Avro schema
  let avro_schema = Schema::parse_str(schema_str).expect("Failed to parse Avro schema");

  // Create a record based on the schema
  let mut record: HashMap<String, Value> = HashMap::new();
  record.insert("name".to_string(), Value::String("Redpanda".to_string()));
  record.insert("age".to_string(), Value::Int(5));

  // Serialize the record into a binary format using the Avro schema
  let mut writer = Writer::new(&avro_schema, Vec::new());
  writer.append(Value::Record(vec![
    ("name".to_string(), record["name"].clone()),
    ("age".to_string(), record["age"].clone()),
  ])).expect("Failed to write record");
  let encoded_binary = writer.into_inner().expect("Failed to get binary data");

  println!("Encoded binary: {:?}", encoded_binary);

  // Initialize the Schema Registry client
  let mut client = SchemaRegistryClient::new();

  // Register the schema in the Schema Registry
  let schema = RPDSchema::new_avro(schema_str.to_string(), vec![]);
  let subject_schema = client.create_schema("my_subject", schema)?;
  println!("Registered new schema ID: {:?}", subject_schema.id());

  // Register the transform function
  on_record_written(my_transform);
}

// Required callback, even if it does nothing
fn my_transform(_event: WriteEvent, _writer: &mut RecordWriter) -> Result<()> {
  Ok(())
}

----
--
======

== Next steps

xref:develop:data-transforms/configure.adoc[]

== Suggested reading

- xref:develop:data-transforms/how-transforms-work.adoc[]
- xref:reference:data-transforms/golang-sdk.adoc[]
- xref:reference:data-transforms/rust-sdk.adoc[]
- xref:reference:rpk/rpk-transform/rpk-transform.adoc[`rpk transform` commands]
